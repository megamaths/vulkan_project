#version 450

struct sphere{
    //xyz is center w is radius
    vec4 dim;
};

struct triangle{
    vec3 v1;
    vec3 v2;
    vec3 v3;
};

struct material{
    vec3 col;
    vec3 emmision;
    float roughness;
};


layout (binding = 0, rgba16) uniform writeonly image2D outputImage;

layout (binding = 1, rgba16) uniform readonly image2D lastOutputImage;

layout (binding = 2) uniform computeState{
    vec2 screenExtent;
    int frame;
    int numSpheres;
    int numTriangles;
} state;

layout(binding = 3) uniform spheres{
    //xyz is center w is radius
    vec4 dim[16];
    // material index
    ivec4 mat[4];
} s;

layout(binding = 4) uniform materials{
    //xyz is colour w is roughness
    vec4 colAndR[16];
    // xyz is emmision w not used yet
    vec4 emmision[16];
} m;

layout(binding = 5) uniform triangles{
    vec3 v1[16];
    vec3 v2[16];
    vec3 v3[16];
} t;

struct ray{
    vec3 dir;
    vec3 start;
    // cumalative colour
    vec3 colour;
    // colour absorbsion
    vec3 absorbsion;
};



float intersectSphere(ray testRay, sphere testSphere){

	vec3 L = testSphere.dim.xyz - testRay.start;
	float tc = dot(L, testRay.dir);
	if ( tc < 0.0 ) return 65536;
	
	float d2 = abs((tc*tc) - (dot(L,L)));
    float r2 = testSphere.dim.w*testSphere.dim.w;
	if ( d2 > r2) return 65536;
	
	float t1c = sqrt( r2 - d2 );
	
	float t1 = tc - t1c;
	float t2 = tc + t1c;

	if ( t1 < 0.0) return t2;
    return t1;
}

vec3 normalSphere(ray testRay ,float d, vec3 center){
    return normalize(testRay.start+testRay.dir*d-center);
}

vec3 normalTriangle(triangle t){
    return normalize(cross(t.v2-t.v1,t.v3-t.v1));
}

float intersectTriangle(ray testRay, triangle testTri){

    vec3 n = normalTriangle(testTri);
    float d = -dot(n,testTri.v1);

    float t = - (dot(n, testRay.start) + d) / dot(n, testRay.dir);
    // dist = abs(n.p + d)/n.v

    if (t < 0){
        return 65536;
    }

    vec3 pos = testRay.start + t*testRay.dir;

    vec3 edge0 = testTri.v2 - testTri.v1;
    vec3 edge1 = testTri.v3 - testTri.v2;
    vec3 edge2 = testTri.v1 - testTri.v3;
    vec3 C0 = pos - testTri.v1;
    vec3 C1 = pos - testTri.v2;
    vec3 C2 = pos - testTri.v3;
    vec3 sides = vec3(dot(n, cross(edge0, C0)) > 0 ,dot(n, cross(edge1, C1)) > 0 , dot(n, cross(edge2, C2)) > 0);
    if (sides[0] == sides[1] && sides[0] == sides[2]) return t; // P is inside the triangle

	return 65536;
}


int seed = 0;

void setSeed(int x){
    seed = x;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
}

int randVal(){
    
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

vec3 randDirection(){

    vec3 dir = vec3(randVal()%256/128.0-1.0,randVal()%256/128.0-1.0,randVal()%256/128.0-1.0);
    for (int i = 0; i < 4 && length(dir) > 1; i++){
        dir = vec3(randVal()%256/128.0-1.0,randVal()%256/128.0-1.0,randVal()%256/128.0-1.0);
    }

    return normalize(dir);
}

ray traceRay(ray mainRay){

    ray retRay;
    retRay.colour = mainRay.colour;
    retRay.absorbsion = mainRay.absorbsion;


    vec3 normal = vec3(0,0,0);
    float dist = 65536;

    vec3 newCol = vec3(0);
    vec3 emmision = vec3(0.0);

    float abience = 0.01;

    float roughness = 0;

    

    for (int i = 0; i < state.numSpheres && i < 16; i++){
        sphere newSphere;

        newSphere.dim = s.dim[i];
        int mindx = s.mat[i/4][i%4];

        float newdist = intersectSphere(mainRay, newSphere);
        if (newdist < dist){
            normal = normalSphere(mainRay,newdist,newSphere.dim.xyz);
            newCol = m.colAndR[mindx].xyz;
            emmision = m.emmision[mindx].xyz;
            roughness = m.colAndR[mindx].w;
        }
        dist = abs(min(dist,newdist));
    }

    triangle tri;
    tri.v1 = vec3(-3,0,3);
    tri.v2 = vec3(-3,4,3);
    tri.v3 = vec3(1,0,3);

    float newdist = intersectTriangle(mainRay, tri);
    if (newdist < dist){
        vec3 pos = mainRay.start + mainRay.dir*newdist;
        vec3 n = normalTriangle(tri);
        vec3 edge0 = tri.v2 - tri.v1;
        vec3 edge1 = tri.v3 - tri.v2;
        vec3 edge2 = tri.v1 - tri.v3;
        vec3 C0 = pos - tri.v1;
        vec3 C1 = pos - tri.v2;
        vec3 C2 = pos - tri.v3;
        vec3 sides = vec3(dot(n, cross(edge0, C0)) , dot(n, cross(edge1, C1)), dot(n, cross(edge2, C2)));
        normal = normalTriangle(tri);
        if (dot(normal,mainRay.dir) > 0){
            normal *= -1;
        }
        newCol = sides;//m.colAndR[0].xyz;
        emmision = sides*0.1;//m.emmision[0].xyz;
        roughness = 10;
    }
    dist = abs(min(dist,newdist));

    for (int i = 0; i < state.numTriangles && i < 16 ;i++){
        triangle tri;
        tri.v1 = t.v1[i];
        tri.v2 = t.v2[i];
        tri.v3 = t.v3[i];

        float newdist = intersectTriangle(mainRay, tri);
        if (newdist < dist){
            vec3 pos = mainRay.start + mainRay.dir*newdist;
            vec3 n = normalTriangle(tri);
            vec3 edge0 = tri.v2 - tri.v1;
            vec3 edge1 = tri.v3 - tri.v2;
            vec3 edge2 = tri.v1 - tri.v3;
            vec3 C0 = pos - tri.v1;
            vec3 C1 = pos - tri.v2;
            vec3 C2 = pos - tri.v3;
            vec3 sides = vec3(dot(n, cross(edge0, C0)) , dot(n, cross(edge1, C1)), dot(n, cross(edge2, C2)));
            normal = normalTriangle(tri);
            if (dot(normal,mainRay.dir) > 0){
                normal *= -1;
            }
            newCol = sides;//m.colAndR[0].xyz;
            emmision = sides*0.1;//m.emmision[0].xyz;
            roughness = 10;
        }
        dist = abs(min(dist,newdist));
    }



    if (dist > 65535){
        retRay.absorbsion = vec3(0);
        return retRay;// ?? as absorbsion is 0 should not try to reflect of the void
    }

    if (randVal()/256%16 == 0){
        roughness = 0;
    }


    

    // if hit
    float nDotL = -dot(normal,mainRay.dir);

    vec3 reflectRay = reflect(mainRay.dir,normal)*1.0;
    vec3 randDir = randDirection()*roughness;

    if (dot(randDir,normal) < 0){
        randDir = -randDir;
    }

    newCol = abs(newCol);

    retRay.dir = normalize(reflectRay + randDir);
    retRay.start = mainRay.start + mainRay.dir * dist  +  retRay.dir *0.001;// not sure if last bit is nesisary it should prevent coliding with same object 2ce
                                                                            // appears only nessisary for triangles not spheres
    retRay.colour = mainRay.colour + (mainRay.absorbsion)*emmision*nDotL + newCol*abience;
    retRay.absorbsion *= newCol;

    return retRay;
}

// work group max size on this computer is 1024 
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main(){

    ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    vec2 xy_float = vec2(gl_GlobalInvocationID.x / float(size.x), gl_GlobalInvocationID.y / float(size.y));
    setSeed(state.frame*1000000+(xy_int.x*1000+xy_int.y));


    ray mainray;

    vec3 colour = vec3(0);

    int numRays = 16;

    for (int i = 0; i < numRays; i++){
        mainray.start = vec3(-5,0,-5);
        mainray.dir = normalize(vec3((xy_float+vec2(-0.5,-0.5))*state.screenExtent,1.0));
        mainray.colour = vec3(0.0);
        mainray.absorbsion = vec3(1.0);

        float theta = -0.5;
        vec3 newdir = vec3(cos(theta)*mainray.dir[0]-sin(theta)*mainray.dir[2],mainray.dir[1],sin(theta)*mainray.dir[0]+cos(theta)*mainray.dir[2]);
        mainray.dir = newdir;

        for (int itr = 0; itr < 10; itr++){

            mainray = traceRay(mainray);
            if (length(mainray.absorbsion) < 0.01){
                break;
            }
        }
        colour += mainray.colour /float(numRays);
    }
    //imageStore(outputImage, xy_int, vec4(vec3(1-dist) , 1.0f));

    vec3 sampleColour = imageLoad(lastOutputImage, xy_int).rgb;

    float keepOld = min(state.frame/float(1+state.frame),0.995);

    colour = (sampleColour*keepOld+colour*(1-keepOld));
    colour = abs(colour);
    imageStore(outputImage, xy_int, vec4(colour , 1.0f));
}