#version 450



layout (binding = 0, rgba8) uniform writeonly image2D outputImage;

layout(binding = 1) uniform vecTwo{
    vec2 xy;
} screenExtent;

layout(binding = 2) uniform ivecOne{
    int x;
} frameRand;

layout (binding = 3, rgba8) uniform readonly image2D lastOutputImage;


struct ray{
    vec3 dir;
    vec3 start;
    // cumalative colour
    vec3 colour;
    // colour absorbsion
    vec3 absorbsion;
};

float intersectSphere(ray testRay, vec3 spherecenter, float radius){

	vec3 L = spherecenter - testRay.start;
	float tc = dot(L, testRay.dir);
	if ( tc < 0.0 ) return 65536;
	
	float d2 = abs((tc*tc) - (dot(L,L)));
	if ( d2 > radius*radius) return 65536;
	
	float t1c = sqrt( (radius * radius) - (d2) );
	
	float t1 = tc - t1c;
	float t2 = tc + t1c;

	if ( t1 < 0.0) return t2;
    return t1;
}

vec3 normalSphere(ray testRay ,float d, vec3 center){
    return normalize(testRay.start+testRay.dir*d-center);
}

int seed = 0;

void setSeed(int x){
    seed = x;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
}

int randVal(){
    
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

ray traceRay(ray mainRay){

    ray retRay;
    retRay.colour = mainRay.colour;
    retRay.absorbsion = mainRay.absorbsion;


    vec3 normal = vec3(0,0,0);
    float dist = 65536;

    vec3 newCol = vec3(0);
    vec3 emmision = vec3(0.0);

    vec3 spos = vec3(0,0,4);
    float newdist = intersectSphere(mainRay, spos, 0.5);
    if (newdist < dist){
        normal = normalSphere(mainRay,newdist,spos);
        newCol = vec3(0,1,1);
        emmision = newCol*0.1;
    }
    dist = min(dist,newdist);

    spos = vec3(1,2,5);
    newdist = intersectSphere(mainRay, spos, 2.5);
    if (newdist < dist){
        normal = normalSphere(mainRay,newdist,spos);
        newCol = vec3(1,1,1);
        emmision = newCol*0.1;
    }
    dist = min(dist,newdist);

    spos = vec3(-8,-8,16);
    newdist = intersectSphere(mainRay, spos, 5.5);
    if (newdist < dist){
        normal = normalSphere(mainRay,newdist,spos);
        newCol = vec3(1,1,0);
        emmision = vec3(1,1,0);
    }
    dist = min(dist,newdist);

    spos = vec3(8,-6,20);
    newdist = intersectSphere(mainRay, spos, 1.5);
    if (newdist < dist){
        normal = normalSphere(mainRay,newdist,spos);
        newCol = vec3(0,1,0);
        emmision = newCol*0.1;
    }
    dist = min(dist,newdist);



    if (dist > 65535){
        retRay.absorbsion = vec3(0);
        return retRay;// ?? as absorbsion is 0 should not try to reflect of the void
    }


    // if hit
    vec3 reflectRay = reflect(mainRay.dir,normal);
    vec3 randDir = vec3(randVal()%256/128.0-1.0,randVal()%256/128.0-1.0,randVal()%256/128.0-1.0)*3.8;

    if (dot(randDir,normal) < 0){
        randDir = -randDir;
    }

    retRay.dir = normalize(reflectRay + randDir);
    retRay.start = mainRay.start + mainRay.dir * dist  +  retRay.dir *0.001;// not sure if last bit is nesisary it should prevent coliding with same object 2ce

    float reflectivity = 0.1;

    retRay.colour = mainRay.colour + (mainRay.absorbsion)*emmision ;//+ newCol*0.01;
    retRay.absorbsion *= newCol;


    return retRay;
}

// work group max size on this computer is 1024 
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main(){

    ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    vec2 xy_float = vec2(gl_GlobalInvocationID.x / float(size.x), gl_GlobalInvocationID.y / float(size.y));
    setSeed(frameRand.x*1000000+(xy_int.x*1000+xy_int.y));


    ray mainray;

    vec3 colour = vec3(0);

    for (int i = 0; i < 100; i++){
        mainray.start = vec3(0,0,0);
        mainray.dir = normalize(vec3((xy_float+vec2(-0.5,-0.5))*screenExtent.xy,1.0));
        mainray.colour = vec3(0.0);
        mainray.absorbsion = vec3(1.0);

        for (int itr = 0; itr < 8; itr++){

            mainray = traceRay(mainray);
            if (length(mainray.absorbsion) < 0.01){
                break;
            }
        }
        colour += mainray.colour /100.0;
    }
    //imageStore(outputImage, xy_int, vec4(vec3(1-dist) , 1.0f));

    vec3 sampleColour = imageLoad(lastOutputImage, xy_int).rgb;
    colour = (sampleColour*0.9+colour*0.1);
    imageStore(outputImage, xy_int, vec4(colour , 1.0f));
}