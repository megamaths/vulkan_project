#version 450

struct sphere{
    //xyz is center w is radius
    vec4 dim;
};

struct material{
    vec3 col;
    vec3 emmision;
    float roughness;
};


layout (binding = 0, rgba16) uniform writeonly image2D outputImage;

layout (binding = 1, rgba16) uniform readonly image2D lastOutputImage;

layout (binding = 2) uniform computeState{
    vec2 screenExtent;
    int frame;
    int numSpheres;
} state;

layout(binding = 3) uniform spheres{
    //xyz is center w is radius
    vec4 dim[16];
    // material index
    ivec4 mat[4];
} s;

struct ray{
    vec3 dir;
    vec3 start;
    // cumalative colour
    vec3 colour;
    // colour absorbsion
    vec3 absorbsion;
};



float intersectSphere(ray testRay, sphere testSphere){

	vec3 L = testSphere.dim.xyz - testRay.start;
	float tc = dot(L, testRay.dir);
	if ( tc < 0.0 ) return 65536;
	
	float d2 = abs((tc*tc) - (dot(L,L)));
    float r2 = testSphere.dim.w*testSphere.dim.w;
	if ( d2 > r2) return 65536;
	
	float t1c = sqrt( r2 - d2 );
	
	float t1 = tc - t1c;
	float t2 = tc + t1c;

	if ( t1 < 0.0) return t2;
    return t1;
}

vec3 normalSphere(ray testRay ,float d, vec3 center){
    return normalize(testRay.start+testRay.dir*d-center);
}

int seed = 0;

void setSeed(int x){
    seed = x;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
}

int randVal(){
    
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

vec3 randDirection(){

    vec3 dir = vec3(randVal()%256/128.0-1.0,randVal()%256/128.0-1.0,randVal()%256/128.0-1.0);
    for (int i = 0; i < 4 && length(dir) > 1; i++){
        dir = vec3(randVal()%256/128.0-1.0,randVal()%256/128.0-1.0,randVal()%256/128.0-1.0);
    }

    return normalize(dir);
}

ray traceRay(ray mainRay){

    ray retRay;
    retRay.colour = mainRay.colour;
    retRay.absorbsion = mainRay.absorbsion;


    vec3 normal = vec3(0,0,0);
    float dist = 65536;

    vec3 newCol = vec3(0);
    vec3 emmision = vec3(0.0);

    float abience = 0.01;

    float roughness = 0;
    int sphereNum = 0;


    material mats[8];

    material m1;
    m1.col = vec3(0,1,1);
    m1.emmision = vec3(0,0,0);
    m1.roughness = 0.8;

    material m2;
    m2.col = vec3(1,1,1);
    m2.emmision = vec3(0,0,0);
    m2.roughness = 4.8;

    material m3;
    m3.col = vec3(0,1,0);
    m3.emmision = vec3(0.01,0.01,0.01);
    m3.roughness = 0.8;

    material m4;
    m4.col = vec3(0,0,0);
    m4.emmision = vec3(1,1,0.7);
    m4.roughness = 0.8;

    material m5;
    m5.col = vec3(1,0.5,0.5);
    m5.emmision = vec3(0,0,0);
    m5.roughness = 0.0;

    material m6;
    m6.col = vec3(1,1,1);
    m6.emmision = vec3(10,10,10);
    m6.roughness = 0.0;

    mats[0] = m1;
    mats[1] = m2;
    mats[2] = m3;
    mats[3] = m4;
    mats[4] = m5;
    mats[5] = m6;
    mats[6] = m1;
    mats[7] = m2;
    

    for (int i = 0; i < state.numSpheres && i < 16; i++){
        sphere newSphere;

        newSphere.dim = s.dim[i];
        int mindx = s.mat[i/4][i%4];

        float newdist = intersectSphere(mainRay, newSphere);
        if (newdist < dist){
            normal = normalSphere(mainRay,newdist,newSphere.dim.xyz);
            newCol = mats[mindx].col;
            emmision = mats[mindx].emmision;
            roughness = mats[mindx].roughness;
            sphereNum = i;
        }
        dist = abs(min(dist,newdist));

    }



    if (dist > 65535){
        retRay.absorbsion = vec3(0);
        return retRay;// ?? as absorbsion is 0 should not try to reflect of the void
    }

    if (randVal()/256%16 == 0){
        roughness = 0;
    }


    

    // if hit
    float nDotL = -dot(normal,mainRay.dir);

    vec3 reflectRay = reflect(mainRay.dir,normal)*1.0;
    vec3 randDir = randDirection()*roughness;

    if (dot(randDir,normal) < 0){
        randDir = -randDir;
    }

    newCol = abs(newCol);

    retRay.dir = normalize(reflectRay + randDir);
    retRay.start = mainRay.start + mainRay.dir * dist;//  +  retRay.dir *0.001;// not sure if last bit is nesisary it should prevent coliding with same object 2ce

    retRay.colour = mainRay.colour + (mainRay.absorbsion)*emmision*nDotL + newCol*abience;
    retRay.absorbsion *= newCol;

    return retRay;
}

// work group max size on this computer is 1024 
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main(){

    ivec2 xy_int = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    vec2 xy_float = vec2(gl_GlobalInvocationID.x / float(size.x), gl_GlobalInvocationID.y / float(size.y));
    setSeed(state.frame*1000000+(xy_int.x*1000+xy_int.y));


    ray mainray;

    vec3 colour = vec3(0);

    for (int i = 0; i < 10; i++){
        mainray.start = vec3(0,0,-5);
        mainray.dir = normalize(vec3((xy_float+vec2(-0.5,-0.5))*state.screenExtent,1.0));
        mainray.colour = vec3(0.0);
        mainray.absorbsion = vec3(1.0);

        for (int itr = 0; itr < 4; itr++){

            mainray = traceRay(mainray);
            if (length(mainray.absorbsion) < 0.01){
                break;
            }
        }
        colour += mainray.colour /10.0;
    }
    //imageStore(outputImage, xy_int, vec4(vec3(1-dist) , 1.0f));

    vec3 sampleColour = imageLoad(lastOutputImage, xy_int).rgb;

    float keepOld = min(state.frame/float(1+state.frame),0.95);

    colour = (sampleColour*keepOld+colour*(1-keepOld));
    colour = abs(colour);
    imageStore(outputImage, xy_int, vec4(colour , 1.0f));
}